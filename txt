package main

import "fmt"

type SampleData struct {
	rollNumber int
}

type UserDefinedRedBlackTreeComparator struct{}

func (comparator UserDefinedRedBlackTreeComparator) Compare(lhs, rhs SampleData) int {
	if lhs.rollNumber < rhs.rollNumber {
		return -1
	} else if lhs.rollNumber > rhs.rollNumber {
		return 1
	}
	return 0
}

type Pair struct {
	Key   any
	Value any
}

type RedBlackTreeComparator[K any] interface {
	Compare(a, b K) int
}

type TreeNode[K any, V any] struct {
	key   K
	val   V
	left  *TreeNode[K, V]
	right *TreeNode[K, V]
}

type RedBlackTree[K any, V any] struct {
	root       *TreeNode[K, V]
	comparator RedBlackTreeComparator[K]
}

func (redBlackTree *RedBlackTree[K, V]) insert(key K, val V) {
	if redBlackTree.root == nil {
		redBlackTree.root = &TreeNode[K, V]{key: key, val: val}
		return
	}
	node := redBlackTree.root
	var prev *TreeNode[K, V]
	for node != nil {
		if redBlackTree.comparator.Compare(key, node.key) == -1 {
			prev = node
			node = node.left
		} else if redBlackTree.comparator.Compare(key, node.key) == 1 {
			prev = node
			node = node.right
		} else {
			return
		}
	}
	if redBlackTree.comparator.Compare(key, prev.key) == -1 {
		prev.left = &TreeNode[K, V]{key: key, val: val}
	} else {
		prev.right = &TreeNode[K, V]{key: key, val: val}
	}
}

func (redBlackTree *RedBlackTree[K, V]) InorderTraversal(node *TreeNode[K, V], result *[]*Pair) {
	if node == nil {
		return
	}
	redBlackTree.InorderTraversal(node.left, result)
	*result = append(*result, &Pair{Key: node.key, Value: node.val})
	redBlackTree.InorderTraversal(node.right, result)
}

func (redBlackTree *RedBlackTree[K, V]) PostOrderTraversal(node *TreeNode[K, V], result *[]*Pair) {
	if node == nil {
		return
	}
	redBlackTree.PostOrderTraversal(node.right, result)
	*result = append(*result, &Pair{Key: node.key, Value: node.val})
	redBlackTree.PostOrderTraversal(node.left, result)
}

func (redBlackTree *RedBlackTree[K, V]) getSortedElements(isSortedAscending bool) []*Pair {
	var sortedElements []*Pair
	if isSortedAscending {
		redBlackTree.InorderTraversal(redBlackTree.root, &sortedElements)
	} else {
		redBlackTree.PostOrderTraversal(redBlackTree.root, &sortedElements)
	}
	return sortedElements
}
func (redBlackTree *RedBlackTree[K, V]) erase(key K) int {
	var node = redBlackTree.root
	var prev *TreeNode[K, V]
	for node != nil {
		if redBlackTree.comparator.Compare(key, node.key) == -1 {
			prev = node
			node = node.left
		} else if redBlackTree.comparator.Compare(key, node.key) == 1 {
			prev = node
			node = node.right
		} else {
			break
		}
	}
	if node == nil {
		return -1
	}

	if node.left == nil && node.right != nil {
		rightPart := node.right
		if prev.left == node {
			prev.left = rightPart
		} else {
			prev.right = rightPart
		}
		return 1
	} else if node.right == nil && node.left != nil {
		leftPart := node.left
		if prev.left == node {
			prev.left = leftPart
		} else {
			prev.right = leftPart
		}
		return 1
	}
	redBlackTree.ReArrangeConnectionsAndGetTop(node, prev)
	return 1
}
func (redBlackTree *RedBlackTree[K, V]) ReArrangeConnectionsAndGetTop(node *TreeNode[K, V], grandfather *TreeNode[K, V]) *TreeNode[K, V] {
	prevNode := node
	rightNode := node.right
	root := node
	node = node.left
	for node != nil {
		prevNode = node
		node = node.right
	}
	prevNode.right = rightNode
	if grandfather == nil {
		return root.left
	}
	if grandfather.left == root {
		grandfather.left = root.left
	} else {
		grandfather.right = root.left
	}
	return root.left
}

func main() {
	comparator := UserDefinedRedBlackTreeComparator{}
	tree := &RedBlackTree[SampleData, string]{comparator: comparator}

	data5 := SampleData{rollNumber: 5}
	val5 := "e"
	tree.insert(data5, val5)

	data9 := SampleData{rollNumber: 9}
	val9 := "i"
	tree.insert(data9, val9)

	data1 := SampleData{rollNumber: 10}
	val1 := "a"
	tree.insert(data1, val1)

	data2 := SampleData{rollNumber: 20}
	val2 := "b"
	tree.insert(data2, val2)

	data3 := SampleData{rollNumber: 5}
	val3 := "c"
	tree.insert(data3, val3)

	data4 := SampleData{rollNumber: 4}
	val4 := "d"
	tree.insert(data4, val4)

	data6 := SampleData{rollNumber: 6}
	val6 := "f"
	tree.insert(data6, val6)

	data7 := SampleData{rollNumber: 7}
	val7 := "g"
	tree.insert(data7, val7)

	data8 := SampleData{rollNumber: 8}
	val8 := "h"
	tree.insert(data8, val8)

	tree.erase(data2)
	sortedElements := tree.getSortedElements(true)
	for i := 0; i < len(sortedElements); i++ {
		if key, ok := sortedElements[i].Key.(SampleData); ok {
			fmt.Println(key.rollNumber)
		}
		if val, ok := sortedElements[i].Value.(string); ok {
			fmt.Println(val)
		}
	}

	fmt.Println("hamad")
}
